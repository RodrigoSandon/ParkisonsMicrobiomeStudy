}
View(df)
View(df_only_dups)
library(hash)
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
}
library(stringr)
library(hash)
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
}
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
tryCatch({
if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
}, error=function(e){})
}
View(h)
h
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
tryCatch({
if (is.empty(h)){
h[key] <- list()
} else if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
}, error=function(e){})
}
View(h)
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
if (is.empty(h)){
h[key] <- list()
} else if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
View(h)
h <- make.keys(1:22)
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
if (is.empty(h)){
h[key] <- list()
} else if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h <- hash(make.keys(1:22))
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
if (is.empty(h)){
h[key] <- list()
} else if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h <- hash(make.keys(1:22))
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
#if (is.empty(h)){h[key] <- list()}
if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
#first turn list of duplicated ids into their respective chromosome #s
h <- hash(1:22)
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
#if (is.empty(h)){h[key] <- list()}
if (!has.key(key, h)) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h
h <- hash(make.keys(1:22))
h
h <- hash(1:22)
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
#if (is.empty(h)){h[key] <- list()}
if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
is.hash(h)
h <- hash()
is.hash(h)
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
#if (is.empty(h)){h[key] <- list()}
if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
value <- i
#tryCatch({
if (is.null(h)){
h[key] <- list()
} else if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
has.key(1,h)
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
key <- splitList[0]
print(key)
value <- i
#tryCatch({
if (is.null(h)){
h[key] <- list()
} else if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
print(splitList)
key <- splitList[0]
print(key)
value <- i
#tryCatch({
if (is.null(h)){
h[key] <- list()
} else if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
splitList[0]
splitList[0][0]
for (i in duplicates) {
splitList <- list(str_split(i,":"))
print(splitList)
key <- splitList[0]
print(key)
value <- i
#tryCatch({
if (is.null(h)){
h[key] <- list()
} else if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":")
print(splitList)
key <- splitList[0]
print(key)
value <- i
#tryCatch({
if (is.null(h)){
h[key] <- list()
} else if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":", simpligy = TRUE)
print(splitList)
key <- splitList[0]
print(key)
value <- i
#tryCatch({
if (is.null(h)){
h[key] <- list()
} else if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
#first turn list of duplicated ids into their respective chromosome #s
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":", simplify = TRUE)
print(splitList)
key <- splitList[0]
print(key)
value <- i
#tryCatch({
if (is.null(h)){
h[key] <- list()
} else if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
#first turn list of duplicated ids into their respective chromosome #s
splitList[1,1]
splitList[1,2]
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":", simplify = TRUE)
key <- splitList[1,1]
value <- i
#tryCatch({
if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
View(h)
h
length(h)
h <- hash()
for (i in duplicates) {
splitList <- str_split(i,":", simplify = TRUE)
key <- splitList[1,1]
value <- i
#tryCatch({
if (!(has.key(key, h))) { #if no key value pair existing
h[key] <- list()
h[key] <- append(h[[key]], value)
} else {
h[key] <- append(h[[key]], value) #if exist already
}
#}, error=function(e){})
}
h[1][1]
h[1,1]
names[h]
names(h)
get(h[[1]],1)
h$"1"
countOfids_inH <- 0
for (i in 1:20) {
for (j in h$i){
countOfids_inH = countOfids_inH + 1
}
}
countOfids_inH
countOfids_inH <- 0
for (i in 1:20) {
print(i)
for (j in h$i){
countOfids_inH = countOfids_inH + 1
}
}
countOfids_inH <- 0
for (i in 1:20) {
for (j in h$i){
print(j)
countOfids_inH <- countOfids_inH + 1
}
}
h$'1'
countOfids_inH <- 0
for (i in 1:20) {
for (j in h$paste("'",i,"'",sep = "")){
#print(j)
countOfids_inH <- countOfids_inH + 1
}
}
countOfids_inH <- 0
for (i in 1:20) {
for (j in h$tostring(i)){
#print(j)
countOfids_inH <- countOfids_inH + 1
}
}
countOfids_inH <- 0
for (i in 1:20) {
i_toString <- toString(i)
print(i_toString)
typeof(i_toString)
for (j in h$i_toString){
#print(j)
countOfids_inH <- countOfids_inH + 1
}
}
countOfids_inH <- 0
for (i in 1:20) {
i_toString <- toString(i)
#print(i_toString)
#typeof(i_toString)
for (j in h$i_toString){
print(j)
countOfids_inH <- countOfids_inH + 1
}
}
h$"1"[1]
length(h$"1")
countOfids_inH <- 0
for (i in 1:20) {
i_toString <- toString(i)
#print(i_toString)
#typeof(i_toString)
countOfids_inH <- countOfids_inH + length(h$i_toString)
}
countOfids_inH
countOfids_inH <- 0
for (i in 1:20) {
i_toString <- toString(i)
#print(i_toString)
#typeof(i_toString)
print(length(h$i_toString))
countOfids_inH <- countOfids_inH + length(h$i_toString)
}
countOfids_inH <- 0
for (i in 1:20) {
print(i)
i_toString <- toString(i)
print(i_toString)
print(length(h$i_toString))
countOfids_inH <- countOfids_inH + length(h$i_toString)
}
typeof(i_toString)
typeof('1')
length(h$i_toString)
length(h$1)
length(h$"1")
i_toString
x <- c()
for (i in 1:20) {
x <- c(x, toString(i))
}
x
countOfids_inH <- 0
for (i in x) {
print(length(h$i))
countOfids_inH <- countOfids_inH + length(h$i)
}
names(h)
names(h)[0]
for (i in h) {
print(i)
}
for (i in names(h)) {
print(i)
}
for (i in names(h)) {
print(h$i)
}
values(h)
length(values(h))
values(h, keys=1)
length(list(values(h, keys=1)))
length(values(h, keys=1))
chrs <- c(1,10,11,12,13,14,15,16,17,18,19,2,20,21,22,4,6,7,8,9)
for (i in chrs) {
print(length(values(h,keys=i)))
}
countOfids_inH <- 0
chrs <- c(1,10,11,12,13,14,15,16,17,18,19,2,20,21,22,4,6,7,8,9)
for (i in chrs) {
lenOfKey <- length(values(h,keys=i))
countOfids_inH <- countOfids_inH + lenOfKey
}
countOfids_inH
values(h, keys=1)
type(values(h, keys=1))
typeof(values(h, keys=1))
df_only_dups <- as.data.frame(df)
for (i in 1:nrow(df)){
print(i)
splitt <- str_split(df[i,2],":", simplify = TRUE)
chrID <- splitt[1,1]
if (chrID != '3' || chrID != '5') { #check if the id is in 3 or 5, if so, don't process
chrIDint <- as.integer(chrID)
if (!(df[i,2] %in% values(h,keys=chrIDint))) { # if not in the list of the key chrIDint
print(paste("dropping....",df[i,2], sep = " "))
df_only_dups <- df_only_dups[-c(i),] #then drop entire row
}
}
}
View(df_only_dups)
source('/Volumes/T7Touch/NIHSummer2021/Code/plink_analysis/PRS_postProcessing.R')
setwd("/Volumes/T7Touch/NIHSummer2021/Code/plink_analysis")
real_data <- read.table("output.profile", header = T)
temp_covs <- read.table("test_covs.txt", header = T)
data <- merge(real_data, temp_covs, by = "FID")
data$CASE <- data$PHENO.x - 1
meanControls <- mean(data$SCORE[data$CASE == 0])
sdControls <- sd(data$SCORE[data$CASE == 0])
data$zSCORE <- (data$SCORE - meanControls)/sdControls
grsTests <- glm(CASE ~ zSCORE + SEX + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10 + AAO, family="binomial", data = data)
summary(grsTests)
grsTests <- glm(CASE ~ zSCORE + SEX + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10, family="binomial", data = data)
summary(grsTests)
View(grsTests)
cases <- subset(data, CASE == 1)
meanPop <- mean(cases$SCORE)
sdPop <- sd(cases$SCORE)
cases$zSCORE <- (cases$SCORE - meanPop)/sdPop
grsTests <- lm(AAO ~ zSCORE + SEX + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10, data = cases)
summary(grsTests)
data$CASE[data$CASE ==0] <- "Controls"
data$CASE[data$CASE ==1] <- "PD"
p <- ggplot(data, aes(x= reorder(as.factor(CASE), zSCORE), y=zSCORE, fill=as.factor(CASE))) +
geom_violin(trim=FALSE)
p2 <- p+geom_boxplot(width=0.4, fill="white" ) + theme_minimal()
p2 + scale_fill_manual(values=c("lightblue", "orange")) + theme_bw() + ylab("PD GRS (Z-transformed)") +xlab("") + theme(legend.position = "none")
ggsave("PD_GRS.jpeg", dpi = 600, units = "in", height = 6, width = 6)
data$quantile1 <- ifelse(data$zSCORE <= quantile(data$zSCORE)[2], 1, 0)
data$quantile2 <- ifelse(data$zSCORE > quantile(data$zSCORE)[2] & data$zSCORE <= quantile(data$zSCORE)[3], 1, 0)
data$quantile3 <- ifelse(data$zSCORE > quantile(data$zSCORE)[3] & data$zSCORE <= quantile(data$zSCORE)[4], 1, 0)
data$quantile4 <- ifelse(data$zSCORE > quantile(data$zSCORE)[4], 1, 0)
data$quantiles <- 1
data$quantiles[data$quantile2 == 1] <- 2
data$quantiles[data$quantile3 == 1] <- 3
data$quantiles[data$quantile4 == 1] <- 4
quintileTests <- glm(CASE ~ as.factor(data$quantiles) + AAO + SEX + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10, family="binomial", data = data)
data$quantile1 <- ifelse(data$zSCORE <= quantile(data$zSCORE)[2], 1, 0)
data$quantile2 <- ifelse(data$zSCORE > quantile(data$zSCORE)[2] & data$zSCORE <= quantile(data$zSCORE)[3], 1, 0)
data$quantile3 <- ifelse(data$zSCORE > quantile(data$zSCORE)[3] & data$zSCORE <= quantile(data$zSCORE)[4], 1, 0)
data$quantile4 <- ifelse(data$zSCORE > quantile(data$zSCORE)[4], 1, 0)
data$quantiles <- 1
data$quantiles[data$quantile2 == 1] <- 2
data$quantiles[data$quantile3 == 1] <- 3
data$quantiles[data$quantile4 == 1] <- 4
quintileTests <- glm(CASE ~ as.factor(data$quantiles) + SEX + PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10, family="binomial", data = data)
